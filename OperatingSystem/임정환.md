# Operating System

### OS

UNIX를 기반으로 설명함

- 하드웨어 추상화를 위한 소프트웨어
    - User level process와 Hardware사이의 중간다리
- 운영체제의 역활
    - CPU 스케줄링
    - 메모리 관리
    - 디스크 관리 ( File System )
    - Input / Outpu 디바이스 관리
- 시스템콜
    - User level 프로세스가 직접 접근이 민감한 코드를 Kernel에게 일임
    - User process가 사용할 수 있는 가장 저수준의 API
    - 시스템콜 요청으로 인해 kernel 코드가 실행될 경우 CPU의 modebit가 특권(privilege)모드로 설정되며 Context Switcing이 발생하게됨

### 컴퓨터 구조

- 컴퓨터 요소
    - CPU
        - 중앙 연산장치 , 주 연산이 발생하게되며 현대 폰노이만 구조의 경우 멀티 Core를 사용하고 있다.
        - CPU는 ALU , Cache 및 레지스터로 구성되어 있으며 구성의 종류는 아키텍처에 따라 다르다 ( Risc-v , Cisc-v , etc … )
    - DMA 컨트롤러
        - IO 발생으로 인해 CPU의 번번한 문맥 교환을 방지하기 위한 장치. IO장치가 메모리와 직접정인 통신이 가능하게함
    - 인터럽트
        - 하드웨어 인터럽트 및 소프트웨어 인터럽트 존재. 하드웨어 인터럽트는 IO 디바이스로 인해 발생하며 소프트웨어 인터럽트는 page fault , process fault , trap 등으로 발생

### 메모리

- 메모리 계층 구조
    - 메모리는 캐시 > 주기억장치 > 보조기억  순으로 빠른 레이턴시를 가짐
    - 캐시
        - L1 캐시의 레이턴시는 0.5 ns 이며  메모리의 경우는 ms단위를 가지게된다.
        - 많은 연산들이 Locality에 따라 caching전략을 통해서 속도를 최적화 한다.
            - 메모리 지역 참조성 : 한번 hit한 물리적 메모리공간은 다시 참조할 확률이 높다.
            - 메모리 시간 참조성 : 최근에 hit한 물리적 메모리공간을 다시 참조할 확률이 높다.
            - 현대 컴파일러 성능 최적화의 근간
- 가상 메모리
    - process는 운영체제가 제공하는 ‘가상 메모리’로 인하여 (보통) 4GB의 메모리를 사용하고 있다는 ‘착각’을 하게 됨
        - 운영체제가 User process에게 제공하는 메모리 추상화기법
    - 프로세스가 사용중인 가상적인 메모리 공간이 CPU의 내부 장치인 MMU ( Memory Management Unit) 으로 인하여 실제 물리 메모리공간으로 변환됨
    - 운영체제는 해당 매핑정보를 ‘TLB’라는 자료구조에 보관하여 가상 메모리와 물리 메모리를 매핑함
    - 스와핑
        - 프로세스가 현재 물리 메모리에 load되어있지 않은 page에 접근할 경우 페이지 부재가 발생 → 영속성을 가진 하드 디스크와 swap함
        - Swapping 비율이 높아지게될 경우 성능 하락이 발생
    - 메모리 할당 전략 : 프로세스 page들을 실제 물리메모리에 어떻게 할당할 것인가?
        - 연속할당
            - 실제 메모리 공간에 페이지들을 선형적으로 할당
            - 현대 운영체제에서 사용되지 않음
        - 불연속 할당
            - 메모리를  특정한 page로 나눔 ( 보통 4KB == 4 * 10 ^ 6 Btyes )
            - 페이징 기법
                - 동일한 페이지로 메모리를 나누어 교체함
            - 세그멘테이션
                - 물리적 크기가 아닌 process 주소공간의 의미적 단위인 Stack , Heap , BSS , Data 등으로 나눔.
                - 다른 영역의 침범을 막아 보안에 이점을 가지지만 , 크기가 일정하지 않음
            - 페이지드 세그멘테이션
                - 위 두개를 합친 기법 , 의미 단위로 세그먼트로 나눠 동일 크기 페이지로 나눔
    - 페이지 교체 알고리즘
        - FIFO
        - LRU
            - 가장 오래전 참조된 페이지를 교체함. linked-list , hash 등으로 구현 가능
        - NUR
            - 원형 자료구조
            - LRU를 선형으로 두며 Used bit를 세팅

### 프로세스와 스레드

- 프로그램의 컴파일 과정
    - 전처리 ( 주석제거 및 헤더파일 병합) → 컴파일 → 어셈블 → 목적파일 링크 → Executable
- Static lib 및 Dynamic lib
    - static lib
        - 프로그램 빌드시 라이브러리를 같이 링크하여 빌드 → 배포 크기가 커지지만 독립적으로 배포가능
    - dynamic lib
        - 프로그램 실행시 라이브러리가 동적으로 링크되어 실행 → 배포 크기가 작아지지만 독립적으로 배포 불가능
- 프로세스 상태
    - 실행 , 중단 ,대기 등등 ..
- 프로세스 메모리 구조

```jsx
 | STACK | .... libs .... | HEAP | BSS | DATA | TEXT | 
	0xffff                                      0x0000
```

- PCB
    - 프로세스들을 관리하기 위한 메타데이터
    - 프로세스 스케줄링 상태 , PID , 프로세스 권한 ( e.g. Sudo ) , Program Counter ( 현재 상태 문맥 ) , CPU Register context , etc …
- Context Switching
    - 스레드나 프로세스가 스케줄링될때 발생하는 레지스터 값 변환의 오버헤드
    - 스레드끼리는 HEAP , TEXT , DATA를 공유하기때문에 상대적으로 문맥 교환의 오버헤드가 적다.
- 멀티 프로세스
    - 다중 프로세스를 통해서 작업을 처리
        - e.g. 크롬 브라우저의 tab이 좋은 예시. 각각은 멀티 프로세스로 작동함
- IPC
    - Inter Process Comunication , 프로세스 간 통신
    - 가상 메모리로 인하여 각 프로세스는 서로 다른 메모리 공간을 바라봄.  데이터 공유를 위해서는 IPC가 필요
        - 공유 메모리
            - 운영체제가 프로세스에게 동일한 메모리영역을 할당해줌
        - 파일 시스템
            - 운영체제가 관리하는 파일 시스템을 통하여 정보를 공유
                - e.g.  메모장 프로그램으로 작성한 test.txt를 활용하여 SWEA 사용
        - 소켓
            - 운영체제가 제공하는 네트워크 추상화. 현대 인터넷은 운영체제의 소켓 API를 근간으로 함
        - PIPE
            - 익명 파이프
                - 부모 프로세스와 자식 프로세스간의 단방향 구조.
            - 비익명 파이프
                - 부모 프로세스뿐만 아닌 프로세스끼리 파이프로 통신
        - 메시지 큐
            - 생산자 - 소비자 형태를 가짐
            - 메시지 큐에 ‘생산자’가 정보를 넣고 ‘소비자’는 해당 정보를 꺼내어서 사용
- 스레드와 멀티스레딩
    - 서로 다른 메모리 주소공간을 가지는 프로세스와 달리 스레드는 같은 주소공간을 공유 ( HEAP , TEST , DATA )
- 공유자원과 임계영억
    - 멀티 스레딩을 통해 단일 프로세스의 공유자원에 접근할경우 발생가능
        - 프로그램 code는 결국 어셈블리어의 집합 , a = a + 1 과 같은 코드를 어셈블리어로 보자면
        
        ```jsx
        LOAD $rdi , 1 
        ADD $rdi , 1 
        STORE 0xffff , $rid 
        ```
        
        다음과 같은 과정처럼 몇 개의 명령어가 필요함. 명령어들이 Atomic하지 않으므로 해당 명령어를 실행 중 다른 스레드에서 공유 자원에 접근하게 될 경우 비일관성 문제등이 발생할 수 있음 
        
    - 뮤텍스
        - Mutual Exclusive ( 상호배제 )
        - 공유되는 임계 영역 코드에 진입할때 Atomic한 mutex변수를 locking 및 unlocking을 통하여 진입을 조절할 수 있음
    - 세마포어
        - 주로 동기화에 사용됨
        - Mutex는 binary 형태이지만 semaphore는 동기화할 만큼의 크기의 정수값을 존재하고 이를 down( 내리거나) 혹 up ( 올려서 ) 동기화
    - 데드록
        - locking을 잘못 설정할 경우 스레드끼리 서로 상대편이 unlock되기만을 기다리느라 프로세스가 정지하는 Dead Lock 발생가능
- CPU 스케줄링 알고리즘
    - 선점형
        - 프로세스가 점유중인 CPU를 뺐을 수 있음 → 현대 운영체제 스케줄링
            - Round Robin
            - Multilevel Feedback Queue
    - 비선점형
        - 그 반대
            - FCFS
                - 먼저 온것을 순서대로 처리 → 쓰레기
            - SJF
                - 짧은 것 부터 처리 → 이론상 좋지만 , 할 수 없음